MySql基本操作：
DDL：
    数据定义语言（Data Define Language），用于定义数据库模式。主要的DDL动词：CREATE（创建）、DROP（删除）、
ALTER（修改）、TRUNCATE（截断）、RENAME（重命名）

主键（primary key）：
    表中的每一行都应该具有可以唯一标识自己的一列，这个承担标识作用的列称为主键。主键是唯一的，一个数据表中只能包含一个
主键，可以使用主键来查询数据，一般设ID号为主键。
外键（foreign key）：
    外键为某个表中的一列，它又是另一个表的主键值，定义了两个表的关系，用来将两个表建立联系。例如两个表（一个vendors表，
一个products表），vendors表存储所有供应商信息；products表存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储
其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应
供应商的详细信息。

SHOW DATABASES;   返回可用的数据库列表
+--------------------+
| Database           |
+--------------------+
| information_schema |
| goods              |
| mysql              |
| performance_schema |
| t1                 |
+--------------------+
USE t1;   选择数据库
SHOW TABLES;   获得数据库内的表的列表
+--------------+
| Tables_in_t1 |
+--------------+
| student      |
+--------------+
SHOW COLUMNS FROM student;   显示表列
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |  字段名、数据类型、是否允许Null、键信息、默认值、其他信息
+-------+----------+------+-----+---------+-------+
| Sno   | char(5)  | NO   | PRI | NULL    |       |
| Sname | char(20) | YES  |     | NULL    |       |
| Ssex  | char(1)  | YES  |     | NULL    |       |
| Sdept | char(15) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+


一：创建和操纵表
1、创建数据库：
CREATE DATABASE market;

2、创建表：
USE market;
CREATE TABLE orders
(
  order_num     int         NOT NULL AUTO_INCREMENT,
  order_date    datetime    NOT NULL,
  cust_id       int         NOT NULL,
  PRIMARY KEY (order_num)
);
AUTO_INCREMENT自动增量，每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（例如，通过使它成为主键）。
CREATE TABLE orderitems
(
  order_num        int          NOT NULL,
  order_item       int          NOT NULL,
  prod_id          char(10)     NOT NULL,
  quantity         int          NOT NULL    DEFAULT 1,
  item_price       decimal(8,2) NOT NULL,
  PRIMARY  KEY (order_num,order_item)
);
DEFAULT默认值，如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。

3、更新表：
使用ALTER TABLE更改表结构，可以分两行：
1、在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）
2、所做更改的列表
ALTER TABLE vendors
ADD vend_phone char(20);
这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。
ALTER TABLE vendors
DROP COLUMN vend_phone;
删除刚刚添加的列

4、删除表：
DROP TABLE customers;

5、重命名表：
RENAME TABLE customers2 TO customers;


二：插入数据
1、插入完整的行





三：检索数据：
1、SELECT语句：从一个或多个表中检索信息
检索单个列：SELECT Sname FROM student;
+-------+
| Sname |
+-------+
| KOBE  |
| CURRY |
+-------+
检索多个列：SELECT Sno,Sname,Ssex FROM student;
+-------+-------+------+
| Sno   | Sname | Ssex |
+-------+-------+------+
| 20123 | KOBE  | 0    |
| 20124 | CURRY | 0    |
+-------+-------+------+
检索所有列：SELECT * FROM student;
+-------+-------+------+------------+
| Sno   | Sname | Ssex | Sdept      |
+-------+-------+------+------------+
| 20123 | KOBE  | 0    | Lakers     |
| 20124 | CURRY | 0    | Basketball |
+-------+-------+------+------------+

2、DISTINCT关键字：只返回不同值的Ssex行，例如：检索一个列（供应商ID），这个列有很多重复值，我不想每个值每次都出现，
只需要知道有哪几家供应商。
SELECT DISTINCT Ssex FROM student;
+------+
| Ssex |
+------+
| 0    |
+------+

3、LIMIT子句：限定行数，返回不多于指定的行
SELECT Sname FROM student LIMIT 1;
+-------+
| Sname |
+-------+
| KOBE  |
+-------+
SELECT Sname FROM student LIMIT 0,1;   指定要检索的开始行和行数，开始行为0，行数为1
+-------+
| Sname |
+-------+
| KOBE  |
+-------+
SELECT Sname FROM student LIMIT 1,1;   检索出来的第一行为行0而不是行1，因此，LIMIT 1,1 将检索出第二行而不是第一行
+-------+
| Sname |
+-------+
| CURRY |
+-------+

4、排序检索数据：
ORDER BY子句：取一个或多个列的名字，据此对输出进行排序，使用 ASC 或 DESC 关键字设置查询结果是按升序或降序排列，默认升序
这个子句如果使用必须是SELECT语句中的最后一条子句。
按一个列排序：
SELECT * FROM student ORDER BY Sname;
+-------+-------+------+------------+
| Sno   | Sname | Ssex | Sdept      |
+-------+-------+------+------------+
| 20124 | CURRY | 0    | Basketball |
| 20123 | KOBE  | 0    | Lakers     |
+-------+-------+------+------------+
SELECT * FROM student ORDER BY Sname DESC;
+-------+-------+------+------------+
| Sno   | Sname | Ssex | Sdept      |
+-------+-------+------+------------+
| 20123 | KOBE  | 0    | Lakers     |
| 20124 | CURRY | 0    | Basketball |
+-------+-------+------+------------+
SELECT Sname FROM student ORDER BY Sname;
+-------+
| Sname |
+-------+
| CURRY |
| KOBE  |
+-------+
按多个列排序：例如：希望雇员清单按姓和名排序（首先按姓排序，然后在每个姓中按名排序）
SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price,prod_name;
+-----------+------------+-----------+
|  prod_id  | prod_price | prod_name |
+-----------+------------+-----------+
|   KFC     |     2.50   |  Cola     |
|   DQ      |     2.50   |  IceCream |
|   C&A     |     4.49   |  Shirt    |
|   Zara    |     8.99   |  Shoe     |
+-----------+------------+-----------+
SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC,prod_name;
DESC关键字只应用到直接位于其前面的列名。在上例中，只对prod_price列指定DESC，对prod_name列不指定。因此，prod_price列以
降序排序，而prod_name列（在每个价格内）仍然按标准的升序排序。如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。
使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值，例如：
SELECT prod_price FROM products ORDER BY prod_price DESC,LIMIT 1;
+------------+
| prod_price |
+------------+
|    8.99    |
+------------+


四：过滤数据：
1、WHERE子句：在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出。
SELECT Sno,Sname FROM student WHERE Sno = 20123;
+-------+-------+
| Sno   | Sname |
+-------+-------+
| 20123 | KOBE  |
+-------+-------+
WHERE子句操作符：= 等于  <> 不等于  != 不等于  < 小于  <= 小于等于  > 大于  >= 大于等于  BETWEEN 在指定的两个值之间
SELECT prod_name,prod_price FROM products WHERE prod_price < 5;
+-------------+------------+
|  prod_name  | prod_price |
+-------------+------------+
|   Cola      |     2.50   |
|   Shirt     |     4.49   |
|   IceCream  |     2.50   |
+-------------+------------+
SELECT prod_name,prod_price FROM products WHERE prod_price BETWEEN 1 AND 3;
+-------------+------------+
|  prod_name  | prod_price |
+-------------+------------+
|   Cola      |     2.50   |
|   IceCream  |     2.50   |
+-------------+------------+
WHERE子句的IS NULL子句可以检索具有NULL值的列
SELECT cust_id FROM customers WHERE cust_email IS NULL;   检索没有电子邮件地址的顾客id
+---------+
| cust_id |
+---------+
|  10002  |
|  10005  |
+---------+
组合WHERE子句：
①、使用AND操作符给WHERE子句附加条件，检索由供应商1003制造且价格小于等于10的所有产品的名称和价格
SELECT prod_id,prod_price,prod_name FROM products WHERE vend_id = 1003 AND prod_price <= 10;
②、OR操作符与AND操作符不同，它指示MySQL检索匹配满足任一条件的行
SELECT prod_name，prod_price,vend_id FROM products WHERE vend_id = 1002 OR vend_id = 1003;
AND操作符比OR操作符优先级高，所以会优先处理AND操作符，可以使用圆括号对多个操作符进行分组
SELECT prod_name,prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price >= 10;
如果不加圆括号的话，会检索出由供应商1003供应的价格大于等于10的商品 或 供应商1002供应的商品（不限价格）
③、IN操作符用来指定条件范围，功能与OR相当
SELECT prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name;
+-------------+------------+
|  prod_name  | prod_price |
+-------------+------------+
|   Bird seed |   10.00    |
|   Carrots   |    2.50    |
|   Detonator |   13.00    |
+-------------+------------+
④、NOT操作符否定它之后所跟的条件
SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN (1002,1003) ORDER BY prod_name;
列出除1002和1003之外的所有供应商供应的产品

2、用通配符进行搜索：
通配符用来匹配值的一部分的特殊字符
例如：怎样搜索产品名中包含文本Bird的所有产品？用简单的比较操作符肯定不行，必须使用通配符，利用通配符可以创建比较特定
数据的搜索模式。搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件。
在搜索子句中使用通配符，必须使用LIKE操作符，LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。
①、百分号（%）通配符
在搜索串中，% 表示出现任意次数的任何字符
SELECT prod_id,prod_name FROM products WHERE prod_name LIKE 'jet%';
+------------+--------------+
|  prod_id   |  prod_name   |
+------------+--------------+
|   JP1000   | JetPack 1000 |
|   JP2000   | JetPack 2000 |
+------------+--------------+
这个例子使用了搜索模式'jet%'，在执行这条子句时，将检索任意以jet开头的词，%告诉MySQL接受jet之后的任意字符，不管它有多少
字符。
SELECT prod_id,prod_name FROM products WHERE prod_name LIKE '%anvil%';
+------------+--------------+
|  prod_id   |  prod_name   |
+------------+--------------+
|   ANV01    | 1 ton anvil  |
|   ANV02    | 2 ton anvil  |
|   ANV03    | 3 ton anvil  |
+------------+--------------+
搜索模式'%anvil%'表示匹配包含文本anvil的值，而不论它之前或之后出现什么字符，如果用'anvil%'则会显示 Empty set。
除了一个或多个字符外，%还能匹配0个字符，%代表搜索模式中给定位置的0个、1个或多个字符。
②、下划线（_）通配符
下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。
用法：SELECT prod_id,prod_name FROM products WHERE prod_name LIKE '_ ton anvil';

3、用正则表达式进行搜索：REGEXP(regular expression)
正则表达式用来匹配文本的特殊字符集合
①、基本字符匹配
SELECT prod_name FROM products WHERE prod_name REGEXP '1000' ORDER BY prod_name;
+--------------+
|  prod_name   |
+--------------+
| JetPack 1000 |
+--------------+
REGEXP后跟的东西作为正则表达式处理
SELECT prod_name FROM products WHERE prod_name REGEXP '.000' ORDER BY prod_name;
+--------------+
|  prod_name   |
+--------------+
| JetPack 1000 |
| JetPack 2000 |
+--------------+
.是正则表达式中一个特殊的字符，它表示匹配任意一个字符
②、进行OR匹配
 | 为正则表达式的OR操作符
SELECT prod_name FROM products WHERE prod_name REGEXP '1000|2000' ORDER BY prod_name;
+--------------+
|  prod_name   |
+--------------+
| JetPack 1000 |
| JetPack 2000 |
+--------------+
可以给出两个以上的OR条件，例如，'1000 | 2000 | 3000'将匹配1000或2000或3000
③、匹配几个字符之一
通过指定一组用[]括起来的字符，例如[123]定义一组字符，它的意思是匹配1或2或3，[]是另一种形式的OR语句
SELECT prod_name FROM products WHERE prod_name REGEXP '[123] Ton' ORDER BY prod_name;
+--------------+
|  prod_name   |
+--------------+
| 1 ton anvil  |
| 2 ton anvil  |
| 3 ton anvil  |
+--------------+
④、匹配范围
集合可用来定义要匹配的一个或多个字符，使用 - 来定义一个范围，例如[0-9]、[a-z]
SELECT prod_name FROM products WHERE prod_name REGEXP '[1-5] Ton' ORDER BY prod_name;
+--------------+
|  prod_name   |
+--------------+
| 1 ton anvil  |
| 2 ton anvil  |
| 3 ton anvil  |
+--------------+
⑤、匹配特殊字符
匹配特殊字符，必须用\\为前导，\\- 表示查找 - ，\\. 表示查找 .，\为反斜杠转义字符
SELECT vend_name FROM vendors WHERE vend_name REGEXP '\\.' ORDER BY vend_name;
+--------------+
|  vend_name   |
+--------------+
|  Hello Inc.  |
+--------------+
⑥、匹配多个实例
SELECT prod_name FROM products WHERE prod_name REGEXP '\\([0-9] sticks?\\)' ORDER BY prod_name;
+---------------+
|   prod_name   |
+---------------+
| TNT (1 stick) |
| TNT (5 sticks)|
+---------------+
sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\\)匹配)


五：聚集函数
AVG():      返回某列的平均值
COUNT():    返回某列的行数
MAX():      返回某列的最大值
MIN():      返回某列的最小值
SUM():      返回某列值之和

1、AVG()
平均值，SELECT AVG(prod_price) AS avg_price FROM products;
AVG只用于单个列，而且列名必须作为函数参数给出，若想获得多个列的平均值，必须使用多个AVG()函数

2、COUNT()
计数，利用COUNT()确定表中行的数目或符合特定条件的行的数目
①：使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。
SELECT COUNT(*) AS num_cust FROM customers;        对顾客表中客户的总数进行计数
+-------------+
|  num_cust   |
+-------------+
|      5      |
+-------------+
②：使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。
SELECT COUNT(cust_email) AS num_cust FROM customers;
+-------------+
|  num_cust   |
+-------------+
|      3      |
+-------------+

3、MAX()
最大值，SELECT MAX(prod_price) AS max_price FROM products;

4、MIN()
最小值，SELECT MIN(prod_price) AS min_price FROM products;

5、SUM()
求和，用来返回指定列值的和
SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;              得出这个商品的总数
SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num = 20005;     得出总的订单金额


六：数据分组
1、GROUP BY子句：
SELECT vend_id,COUNT(*) AS num_prods FROM products GROUP BY vend_id;
+------------+--------------+
|  vend_id   |  num_prods   |
+------------+--------------+
|    1001    |         3    |
|    1002    |         2    |
|    1003    |         7    |
|    1005    |         2    |
+------------+--------------+
GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。

2、HAVING过滤分组（不同于WHERE，WHERE是过滤行，HAVING是过滤分组）
SELECT vend_id,COUNT(*) AS num_prods FROM products GROUP BY vend_id HAVING COUNT(*) > 2;
+------------+--------------+
|  vend_id   |  num_prods   |
+------------+--------------+
|    1001    |         3    |
|    1003    |         7    |
+------------+--------------+
WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。


七：表连接
    关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互
相关联。
1、内连接（INNER JOIN）
内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行，INNER可以不写，则默认为内连接。
SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;







事务：
    事务就是一组原子性的SQL查询，是访问并更新数据库中各种数据项的一个程序执行单元，事务中的操作要么都执行要么都不执行。
比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱、文章等等，
这些数据库操作语句就构成一个事务。

ACID：事务需要满足ACID四个特性
1、A(Atomicity) 原子性：
    一个事务的执行是一个不可分割的最小单元，事务中的所有操作全部执行或全部不执行。
2、C(Consistency) 一致性：
    事务的执行不能破坏数据库的完整性约束，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
3、I(Isolation) 隔离性：
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行效果。实际情况中，事务相互影响的程度受到
隔离级别的影响，事务隔离的级别包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）
和串行化（Serializable）。
4、D(Durability) 持久性：
    事务操作完成后，对数据的修改就是永久的，即便系统故障也不会丢失。

事务隔离级别：由低到高
1、Read uncommitted（读未提交）：一个事务可以读取另一个事务未提交的数据，会导致脏读。
2、Read committed（读提交）：一个事务要等另一个事务提交后才能读取数据，能解决脏读问题，但会造成不可重复读。
3、Repeatable read（可重复读）：在开始读取数据（事务开启）时，不再允许修改操作，能解决不可重复读，但是可能还有幻读问题。
4、Serializable（串行化）：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读和幻读，但是
效率低，比较消耗数据库性能，不建议使用。
大多数数据库默认的事务隔离级别是 Read committed，比如Sql Server、Oracle，MySql默认的是Repeatable read。

脏读、不可重复读和幻读：
1、脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改，事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才
所做的修改，现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）。事务T2读取的数据项就是一个“临时的值”，
称为脏数据。
2、不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的
结果不同。不可重复读对应的是修改，即update操作。
3、幻读：事务T1读取一条指定的where字句所返回的结果集，然后T2新插入一行记录，这行记录恰好可以满足T1所使用的查询条件，
然后T1再次对表进行检索，又看到了T2新插入的数据。幻读对应的是插入insert操作。

数据库存储引擎：
    MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。存储引擎就是如何存储数据、如何为存储的
数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以
称为表类型。 在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种
存储引擎，用户可以根据不同的需求为数据表选择不同的存储引擎。
    事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySql中支持事务的存储引擎有InnoDB和NDB。
1、InnoDB：
    InnoDB是MySql默认的存储引擎，支持事务操作，支持行级锁，行级锁相对于表锁，其粒度更细，允许并发量更大，支持外键引用
完整性约束，缺点是：存储空间会占用比较大。如果应用中需要执行大量的INSERT或UPDATE操作应该使用InnoDB。
2、MyISAM：
    不支持事务，不支持外键，支持表锁，并发性能比较低，通常只用于只读模式，优点是：访问速度快，对事务完整性没有要求。
MyISAM相对简单，效率上优于InnoDB。如果应用中需要执行大量的SELECT操作应该使用MyISAM。

