一、事务
1、事务概念：
    事务就是一组原子性的SQL查询，是访问并更新数据库中各种数据项的一个程序执行单元，事务中的操作要么都执行要么都不执行。
比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱、文章等等，
这些数据库操作语句就构成一个事务。

2、ACID：事务需要满足ACID四个特性
①、A(Atomicity) 原子性：
    一个事务的执行是一个不可分割的最小单元，事务中的所有操作全部执行或全部不执行。
②、C(Consistency) 一致性：
    事务的执行不能破坏数据库的完整性约束，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
③、I(Isolation) 隔离性：
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行效果。实际情况中，事务相互影响的程度受到
隔离级别的影响，事务隔离的级别包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）
和串行化（Serializable）。
④、D(Durability) 持久性：
    事务操作完成后，对数据的修改就是永久的，即便系统故障也不会丢失。

3、事务隔离级别：由低到高
①、Read uncommitted（读未提交）：
    一个事务可以读取另一个事务未提交的数据，会导致脏读。
②、Read committed（读提交）：
    一个事务要等另一个事务提交后才能读取数据，能解决脏读问题，但会造成不可重复读。
③、Repeatable read（可重复读）：
    在开始读取数据（事务开启）时，不再允许修改操作，能解决不可重复读，但是可能还有幻读问题。
④、Serializable（串行化）：
    是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读和幻读，但是效率低，比较消耗数据库
性能，不建议使用。
大多数数据库默认的事务隔离级别是 Read committed，比如Sql Server、Oracle，MySql默认的是Repeatable read。

4、脏读、不可重复读和幻读：
①、脏读：
    事务T1更新了一行记录的内容，但是并没有提交所做的修改，事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才所做的
修改，现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）。事务T2读取的数据项就是一个“临时的值”，称为脏数据。
②、不可重复读：
    事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的结果不同。
不可重复读对应的是修改，即update操作。
③、幻读：
    事务T1读取一条指定的where字句所返回的结果集，然后T2新插入一行记录，这行记录恰好可以满足T1所使用的查询条件，然后T1
再次对表进行检索，又看到了T2新插入的数据。幻读对应的是插入insert操作。


二、数据库存储引擎
    MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。存储引擎就是如何存储数据、如何为存储的
数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以
称为表类型。在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种
存储引擎，用户可以根据不同的需求为数据表选择不同的存储引擎。
    事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySql中支持事务的存储引擎有InnoDB和NDB。
1、InnoDB：
    InnoDB是MySql默认的存储引擎，使用聚簇索引，支持事务操作，支持行级锁，行级锁相对于表锁，其粒度更细，允许并发量更大，
支持外键引用完整性约束，缺点是：存储空间会占用比较大。如果应用中需要执行大量的INSERT或UPDATE操作应该使用InnoDB。
2、MyISAM：
    使用非聚簇索引，不支持事务，不支持外键，支持表锁，并发性能比较低，通常只用于只读模式，优点是：访问速度快，对事务
完整性没有要求。MyISAM相对简单，效率上优于InnoDB。如果应用中需要执行大量的SELECT操作应该使用MyISAM。


三、数据库索引
1、索引介绍：
    数据库索引是用于提高数据库中数据查询速度的，可以类比书的索引（目录），如果想在一本书中找到某个特定主题，一般会先看
书的“索引”，找到对应的页码。数据库存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应
的数据行。用于索引的最好的备选数据列是那些出现在WHERE子句、join子句、ORDER BY或GROUP BY子句中的列。
    例如：select * from table1 where id = 44; 如果没有索引，必须遍历整个表，直到id等于44的这一行被找到为止；有了索引之后
（必须是在id这一列上建立的索引），直接在索引里面找44（也就是在id这一列找），就可以得知这一行的位置，从而找到了这一行。
可见索引是用来定位的。
    聚簇索引按照数据存放的物理位置排序，非聚簇索引的索引顺序与数据物理排列顺序无关。聚簇索引就好比是拼音查询，每一个字母
查询出来的页面顺序跟字母的顺序是一致的，a字母查询出来的页面一定是在c字母查询出来的页面前面；而非聚簇索引就好比是笔画查询，
笔画少的查出来的页面不一定在笔画多的查出来的页面前面，也就是你通过笔画查询的顺序和页面的顺序并不是一致的。因为物理存储
只能有一个顺序，所以一个表最多只能有一个聚簇索引。
    为表设置索引需要付出代价：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）
    一些规则：
    ①、需要加索引的字段，要在where条件中
    ②、数据量少的字段不需要加索引
    ③、如果where条件中是OR关系，加索引不起作用
    ④、符合最左前缀原则

2、索引的数据结构：
    B树索引：节点中的关键字是索引（目录），关键字记录的指针是数据的地址（页码）
    B+树索引：MySQL的InnoDB和MyISAM存储引擎用的都是B+树索引结构
    为什么不用二叉树：简答：二叉树的深度过大造成IO读写过于频繁，因此查询效率低下，B-树是比二叉树“矮胖”的多叉树。
详解：查询索引操作最耗资源的不是在内存中比较，而是磁盘IO。索引是存在磁盘上的，当数据量比较大的时候，索引的大小可能达到
几个G。我们利用索引进行查询的时候，不可能把索引直接加载到内存中，只能一次读取一个磁盘页，一个磁盘页对应着一个节点，一次
读取操作是一个磁盘IO。二叉树查询时，最坏情况下查找的次数是树的高度，即IO次数为树的高度。所以只要树的高度足够低，IO次数少，
就可以提升查找性能。而且B+树相比B树做了优化，B+树非叶子节点只存索引，不存实际的数据地址，所以可以存储更多的索引，索引树
更加的矮胖，IO次数更少；所有叶子节点增加链指针形成链表，并且叶子节点保存了父节点的所有关键字和关键字记录的指针，所以B+树
不需要中序遍历，遍历链表即可。

3、联合索引：
    联合索引就是由多个字段组成的组合索引，如果经常需要使用多个字段的多条件查询（WHERE col1 = … AND col2 = … AND
col3 = …），可以考虑使用联合索引。
    最左前缀原则：Mysql从左到右使用索引中的字段，一个查询可以只使用联合索引中的一部分，但只能是从最左侧开始的部分。例如
索引是key index (a,b,c)，可以支持 a|a,b|a,b,c 3种组合进行查找，但不支持 b,c进行查找（a,c也可以，但是只使用a字段索引，
不会使用c字段）。
    当B+树的数据项是复合的数据结构，比如(name,age,sex)的时候，B+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)
这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和sex，最后得到检索的数据。
但当(20,F)这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，
必须要先根据name来搜索才能知道下一步去哪里查询。当(张三,F)这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个
字段age缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据。


四、MySQL中的锁
1、行级锁、表级锁、页级锁
①、行级锁：
    行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度
最小，但加锁的开销也最大。
②、表级锁：
    表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。
③、页级锁：
    页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢，所以取了折中的
页级，一次锁定相邻的一组记录。
④、存储引擎的锁机制：
    MyISAM 和 MEMORY采用表级锁；InnoDB支持行级锁和表级锁，默认为行级锁

2、共享锁和排它锁：
①、共享锁：
    共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），
直到已释放所有共享锁。事务T对数据A加上共享锁后，其他事务只能对A再加共享锁，不能加排他锁，获准共享锁的事务只能读数据，
不能修改数据。
②、排它锁：
    排他锁又称写锁，事务T对数据A加上排他锁后，其他事务不能再对A加任何类型的锁。获取排他锁的事务既能读数据，又能修改数据。

3、乐观锁和悲观锁：
    乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。无论是乐观锁还是悲观锁，都是人们定义出来
的概念，可以认为是一种思想，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据库中提供的锁机制
（行锁、表锁、共享锁、排它锁）混为一谈。在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。
①、乐观锁：
    总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有
去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。
    相对于悲观锁，在对数据库进行操作的时候，乐观锁并不会使用数据库提供的锁机制，一般的实现乐观锁的方式就是记录数据版本。
②、悲观锁：
    总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，将数据处于锁定状态。关系型
数据库里边用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock
等独占锁就是悲观锁思想的实现。