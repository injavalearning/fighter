事务：
    事务就是一组原子性的SQL查询，是访问并更新数据库中各种数据项的一个程序执行单元，事务中的操作要么都执行要么都不执行。
比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱、文章等等，
这些数据库操作语句就构成一个事务。

ACID：事务需要满足ACID四个特性
1、A(Atomicity) 原子性：
    一个事务的执行是一个不可分割的最小单元，事务中的所有操作全部执行或全部不执行。
2、C(Consistency) 一致性：
    事务的执行不能破坏数据库的完整性约束，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
3、I(Isolation) 隔离性：
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行效果。实际情况中，事务相互影响的程度受到
隔离级别的影响，事务隔离的级别包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）
和串行化（Serializable）。
4、D(Durability) 持久性：
    事务操作完成后，对数据的修改就是永久的，即便系统故障也不会丢失。

事务隔离级别：由低到高
1、Read uncommitted（读未提交）：一个事务可以读取另一个事务未提交的数据，会导致脏读。
2、Read committed（读提交）：一个事务要等另一个事务提交后才能读取数据，能解决脏读问题，但会造成不可重复读。
3、Repeatable read（可重复读）：在开始读取数据（事务开启）时，不再允许修改操作，能解决不可重复读，但是可能还有幻读问题。
4、Serializable（串行化）：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读和幻读，但是
效率低，比较消耗数据库性能，不建议使用。
大多数数据库默认的事务隔离级别是 Read committed，比如Sql Server、Oracle，MySql默认的是Repeatable read。

脏读、不可重复读和幻读：
1、脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改，事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才
所做的修改，现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）。事务T2读取的数据项就是一个“临时的值”，
称为脏数据。
2、不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的
结果不同。不可重复读对应的是修改，即update操作。
3、幻读：事务T1读取一条指定的where字句所返回的结果集，然后T2新插入一行记录，这行记录恰好可以满足T1所使用的查询条件，
然后T1再次对表进行检索，又看到了T2新插入的数据。幻读对应的是插入insert操作。

数据库存储引擎：
    MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。存储引擎就是如何存储数据、如何为存储的
数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以
称为表类型。在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种
存储引擎，用户可以根据不同的需求为数据表选择不同的存储引擎。
    事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySql中支持事务的存储引擎有InnoDB和NDB。
1、InnoDB：
    InnoDB是MySql默认的存储引擎，使用聚簇索引，支持事务操作，支持行级锁，行级锁相对于表锁，其粒度更细，允许并发量更大，
支持外键引用完整性约束，缺点是：存储空间会占用比较大。如果应用中需要执行大量的INSERT或UPDATE操作应该使用InnoDB。
2、MyISAM：
    使用非聚簇索引，不支持事务，不支持外键，支持表锁，并发性能比较低，通常只用于只读模式，优点是：访问速度快，对事务
完整性没有要求。MyISAM相对简单，效率上优于InnoDB。如果应用中需要执行大量的SELECT操作应该使用MyISAM。

数据库索引：
    数据库索引是用于提高数据库中数据查询速度的，可以类比书的索引（目录），如果想在一本书中找到某个特定主题，一般会先看
书的“索引”，找到对应的页码。数据库存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应
的数据行。
    例如：select * from table1 where id = 44; 如果没有索引，必须遍历整个表，直到id等于44的这一行被找到为止；有了索引之后
(必须是在id这一列上建立的索引)，直接在索引里面找44(也就是在id这一列找)，就可以得知这一行的位置，从而找到了这一行。可见
索引是用来定位的。
    聚簇索引按照数据存放的物理位置排序，非聚簇索引的索引顺序与数据物理排列顺序无关。聚簇索引就好比是拼音查询，每一个字母
查询出来的页面顺序跟字母的顺序是一致的，a字母查询出来的页面一定是在c字母查询出来的页面前面；而非聚簇索引就好比是笔画查询，
笔画少的查出来的页面不一定在笔画多的查出来的页面前面，也就是你通过笔画查询的顺序和页面的顺序并不是一致的。因为物理存储
只能有一个顺序，所以一个表最多只能有一个聚簇索引。
    为表设置索引需要付出代价：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

索引的数据结构：
    B树索引：节点中的关键字是索引（目录），关键字记录的指针是数据的地址（页码）
    B+树索引：MySQL的InnoDB和MyISAM存储引擎用的都是B+树索引结构
    为什么不用二叉树：B-树是比二叉树“矮胖”的多叉树。查询索引操作最耗资源的不是在内存中比较，而是磁盘IO。索引是存在磁盘
上的，当数据量比较大的时候，索引的大小可能达到几个G。我们利用索引进行查询的时候，不可能把索引直接加载到内存中，只能一次
读取一个磁盘页，一个磁盘页对应着一个节点，一次读取操作是一个磁盘IO。二叉树查询时，最坏的情况下查找的次数是树的高度，即IO
次数为树的高度。所以只要树的高度足够低，IO次数少，就可以提升查找性能。而且B+树相比B树做了优化，B+树非叶子节点只存索引，不
存实际的数据地址，所以可以存储更多的索引，索引树更加的矮胖，IO次数更少；所有叶子节点增加链指针形成链表，并且叶子节点保存
了父节点的所有关键字和关键字记录的指针，所以B+树不需要中序遍历，遍历链表即可。

