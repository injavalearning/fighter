事务：
    事务就是一组原子性的SQL查询，是访问并更新数据库中各种数据项的一个程序执行单元，事务中的操作要么都执行要么都不执行。
比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱、文章等等，
这些数据库操作语句就构成一个事务。

ACID：事务需要满足ACID四个特性
1、A(Atomicity) 原子性：
    一个事务的执行是一个不可分割的最小单元，事务中的所有操作全部执行或全部不执行。
2、C(Consistency) 一致性：
    事务的执行不能破坏数据库的完整性约束，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
3、I(Isolation) 隔离性：
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行效果。实际情况中，事务相互影响的程度受到
隔离级别的影响，事务隔离的级别包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）
和串行化（Serializable）。
4、D(Durability) 持久性：
    事务操作完成后，对数据的修改就是永久的，即便系统故障也不会丢失。

事务隔离级别：由低到高
1、Read uncommitted（读未提交）：一个事务可以读取另一个事务未提交的数据，会导致脏读。
2、Read committed（读提交）：一个事务要等另一个事务提交后才能读取数据，能解决脏读问题，但会造成不可重复读。
3、Repeatable read（可重复读）：在开始读取数据（事务开启）时，不再允许修改操作，能解决不可重复读，但是可能还有幻读问题。
4、Serializable（串行化）：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读和幻读，但是
效率低，比较消耗数据库性能，不建议使用。
大多数数据库默认的事务隔离级别是 Read committed，比如Sql Server、Oracle，MySql默认的是Repeatable read。

脏读、不可重复读和幻读：
1、脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改，事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才
所做的修改，现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）。事务T2读取的数据项就是一个“临时的值”，
称为脏数据。
2、不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的
结果不同。不可重复读对应的是修改，即update操作。
3、幻读：事务T1读取一条指定的where字句所返回的结果集，然后T2新插入一行记录，这行记录恰好可以满足T1所使用的查询条件，
然后T1再次对表进行检索，又看到了T2新插入的数据。幻读对应的是插入insert操作。

数据库存储引擎：
    MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。存储引擎就是如何存储数据、如何为存储的
数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以
称为表类型。 在Oracle 和SQL Server等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的。而MySql数据库提供了多种
存储引擎，用户可以根据不同的需求为数据表选择不同的存储引擎。
    事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySql中支持事务的存储引擎有InnoDB和NDB。
1、InnoDB：
    InnoDB是MySql默认的存储引擎，支持事务操作，支持行级锁，行级锁相对于表锁，其粒度更细，允许并发量更大，支持外键引用
完整性约束，缺点是：存储空间会占用比较大。如果应用中需要执行大量的INSERT或UPDATE操作应该使用InnoDB。
2、MyISAM：
    不支持事务，不支持外键，支持表锁，并发性能比较低，通常只用于只读模式，优点是：访问速度快，对事务完整性没有要求。
MyISAM相对简单，效率上优于InnoDB。如果应用中需要执行大量的SELECT操作应该使用MyISAM。