Java多线程：

进程：
是系统进行资源分配和调用的独立单位，每一个进程，都有它自己的内存空间和系统资源。进程指的是程序执行时的一个实例，
程序一旦运行就是一个进程。

线程：
是进程的执行单元、执行路径，线程是CPU调度的基本单位。

同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈等），一个进程至少包括一个线程，
一个线程不能独立的存在，它必须是进程的一部分。
开启多个线程是为了同时运行多部分代码，多线程能满足程序员编写高效率的程序来达到充分利用CPU的目的。

多进程是指操作系统能同时运行多个任务（程序）
多线程是指在同一程序中有多个顺序流在执行
JVM启动时就启动了多个线程，至少有两个线程可以分析出来
1、执行main函数的线程
2、负责垃圾回收的线程

并发：
通过CPU调度算法，让用户看上去同时执行，实际上是通过CPU在高度切换并不是真正的同时。

并行：
多个CPU实例或者多台机器同时执行一段处理逻辑，这就是真正的同时。

Java实现多线程的两种方式：（Thread1和Thread2）
方式一：1、继承Thread类
        2、重写Thread类的run方法，并且将线程要执行的代码存放到run方法中
        3、创建继承Thread类的子类的对象，也就是创建线程
        4、线程对象调用start方法，开启线程，线程会自动执行run方法

方式二：1、实现Runnable接口
           存放线程执行代码的类去实现(implements) Runnable接口
        2、重写所实现接口的run方法，并将线程执行代码存放在run方法中
        3、创建Thread对象，也就是创建线程
        4、Thread线程对象调用start方法，启动线程

两种方式的比较：
实现Runnable接口的方式要好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是
设计模式6大原则的核心。
run()方法与start()方法：run()方法里面存放着Thread线程对象需要执行的代码，调用start()方法，让所创建的线程处于
就绪状态。
为什么不调用run方法而用start方法：start()创建了新线程，当调用start()方法时，系统才会开启一个线程，run()方法没有,
run()实际为主线程，它是被当作普通方法的方式调用。


一个线程的生命周期（五种状态）：
新建状态、就绪状态、运行状态、阻塞状态、死亡状态

多线程安全问题：（Ticket）
一：线程安全问题产生的原因：
1、是否有多线程环境，程序中是否使用了多线程
2、是否有共享数据
3、是否有多条语句操作共享数据
当一个线程在执行操作共享数据的代码过程中，其它线程参与了运算，就会导致线程安全问题的产生。

二：多线程安全问题的解决思路：
    就是将操作共享数据的代码封装起来，当有线程在执行这些代码的时候，其他线程就不可以参与运算，必须要当前线程把
这些代码都执行完毕后，其他线程才可以参与运算。

三：解决方案：
    我们使用同步（关键字为synchronized）来解决这种由于多线程同时操作共享数据带来的线程安全问题（火车上的卫生间）
同步可以理解为：我们将多条操作共享数据的语句代码包成一个整体，让某个线程执行时其他线程不能执行（达到多窗口
卖票的同步性，多个窗口可以同时卖（并发），但不会导致重复卖）。
    同步有四种方案：同步代码块、同步方法、volatile实现同步、ReentrantLock实现同步。
注意：同步可以解决问题的根本原因就在于锁对象上，因此要避免线程安全问题，多个线程必须使用同一个锁对象。
    方案一：同步代码块（Ticket1）
        格式：synchronized(对象) {
                        需要被同步的代码;
            }
            这里的锁对象可以是任意对象
    方案二：同步方法（Ticket2）
        格式：把同步（synchronized）加在方法上，这时的锁对象是this
    方案三：


Java线程池：
一：概念：
    线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程而不用自己创建，
使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

二：使用线程池的好处：
1、重用存在的线程，减少线程对象创建、消亡的开销，性能佳
2、可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞
3、提供定时执行、定期执行、单线程、并发数控制等功能

三：四种线程池：
1、newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照
指定顺序(FIFO, LIFO, 优先级)执行。
（只有一个线程的“池”，该线程顺序执行每一个提交的任务）
2、newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
（包含固定数量的线程，空闲线程会一直被保留）
3、newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，
若无可回收，则新建线程。
（必要时创建新线程，空闲线程会被保留60秒）
4、newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
（用于预定执行而构建的固定线程池，替代java.util.Timer）

四：线程池四个基本组成部分：
1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务。
2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务。
3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行
完后的收尾工作，任务的执行状态等。
4、任务队列（TaskQueue）：用于存放没有处理的任务,提供一种缓冲机制。

五：合理配置线程池大小：
一般需要根据任务的类型来配置线程池大小：
如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为Ncpu+1
如果是IO密集型任务，参考值可以设置为2*Ncpu
结论：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。
