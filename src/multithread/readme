Java多线程：

进程：
是系统进行资源分配和调用的独立单位，每一个进程，都有它自己的内存空间和系统资源。进程指的是程序执行时的一个实例，
程序一旦运行就是一个进程

线程：
是进程的执行单元、执行路径，线程是CPU调度的基本单位

同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈等），一个进程至少包括一个线程
一个线程不能独立的存在，它必须是进程的一部分
开启多个线程是为了同时运行多部分代码，多线程能满足程序员编写高效率的程序来达到充分利用CPU的目的

多进程是指操作系统能同时运行多个任务（程序）
多线程是指在同一程序中有多个顺序流在执行
JVM启动时就启动了多个线程，至少有两个线程可以分析出来
1、执行main函数的线程
2、负责垃圾回收的线程

并发：
通过CPU调度算法，让用户看上去同时执行，实际上是通过CPU在高度切换并不是真正的同时

并行：
多个CPU实例或者多台机器同时执行一段处理逻辑，这就是真正的同时

Java实现多线程的两种方式：（Thread1和Thread2）
方式一：1、继承Thread类
        2、重写Thread类的run方法，并且将线程要执行的代码存放到run方法中
        3、创建继承Thread类的子类的对象，也就是创建线程
        4、线程对象调用start方法，开启线程，线程会自动执行run方法

方式二：1、实现Runnable接口
           存放线程执行代码的类去实现(implements) Runnable接口
        2、重写所实现接口的run方法，并将线程执行代码存放在run方法中
        3、创建Thread对象，也就是创建线程
        4、Thread线程对象调用start方法，启动线程

run()方法与start()方法：run()方法里面存放着Thread线程对象需要执行的代码，调用start()方法，让所创建的线程处于就绪状态
为什么不调用run方法而用start方法：start()创建了新线程，当调用start()方法时，系统才会开启一个线程，
run()方法没有,run()实际为主线程，它是被当作普通方法的方式调用
两种方式的比较：
实现Runnable接口的方式要好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模
式6大原则的核心

一个线程的生命周期（五种状态）：
新建状态、就绪状态、运行状态、阻塞状态、死亡状态

多线程安全问题：（Ticket）
线程安全问题产生的原因：
1、是否有多线程环境，程序中是否使用了多线程
2、是否有共享数据
3、是否有多条语句操作共享数据
当一个线程在执行操作共享数据的代码过程中，其它线程参与了运算，就会导致线程安全问题的产生
多线程安全问题的解决思路：
就是将操作共享数据的代码封装起来，当有线程在执行这些代码的时候，其他线程就不可以参与运算，必须要当前线程把这些代码
都执行完毕后，其他线程才可以参与运算
解决方案：
我们使用同步（关键字为synchronized）来解决这种由于多线程同时操作共享数据带来的线程安全问题（火车上的卫生间）
同步可以理解为：我们将多条操作共享数据的语句代码包成一个整体，让某个线程执行时其他线程不能执行（达到多窗口卖票的
同步性，多个窗口可以同时卖（并发），但不会导致重复卖）
同步有四种方案：同步代码块、同步方法、volatile实现同步、ReentrantLock实现同步
注意：同步可以解决问题的根本原因就在于锁对象上，因此要避免线程安全问题，多个线程必须使用同一个锁对象
方案一：同步代码块（Ticket1）
    格式：synchronized(对象) {
                    需要被同步的代码;
          }
          这里的锁对象可以是任意对象
方案二：同步方法（Ticket2）
    格式：把同步（synchronized）加在方法上，这时的锁对象是this
方案三：