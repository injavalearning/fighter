第二部分：自动内存管理机制

第2章：Java内存区域与内存溢出异常
一：JVM内存的划分：
1、Java堆（堆内存）：
    存储的是对象实例和数组（其实数组就是对象），每new一个对象就在堆内存中开辟一个新的存储空间存储此对象实例。
2、方法区：
    在HotSpot里也叫“永久代”，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
3、虚拟机栈（栈内存）：
    存储的是局部变量和对象的引用，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量。
每个线程包含一个栈区，它的生命周期与线程相同。
4、本地方法栈：
    与虚拟机栈所发挥的作用非常相似。
5、程序计数器：
    可以看作是当前线程所执行的字节码文件（class）的行号指示器，保证多线程线程切换后能恢复到正确的执行位置。

堆和栈：
1、堆是用来存放对象的，栈是用来运行程序的。每个方法执行的时候都建立自己的栈内存，方法中定义的局部变量放在栈中，当
方法结束的时候栈也会自动销毁。当我们在程序中创建对象的时候，因为创建对象的成本比较大，为了反复利用，所以就把对象放到
堆里，但是不会自动销毁，而是某一时刻系统自己启用垃圾回收机制进行回收。
2、在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。例如：
    String str = new String("test");
   这条语句，在堆上new了一个值为"test"的String对象，栈上新建一个str来指向上面新建的"test"对象，即str是"test"的引用。
所以Java中对象的新建都是在堆上进行的，对象的引用一般都是在栈上。一般每个方法的调用都会独立有一个栈来保存str这样的
对象的引用变量，在方法返回后，栈会清空，所以引用变量会被清空掉；堆上的对象，如果没有其他的引用变量引用它，就会在某个
合适的时候GC掉。
   当在方法中定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配
的内存空间，该内存空间可以立即被另作他用。
3、堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组
或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了
数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的
数组或对象。
4、堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会
自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
   栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，
缺乏灵活性。
   栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
   int a = 3;
   int b = 3；
   编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，
然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。

创建String对象过程总结：
1、String s = "abc";
创建过程分析：class文件被JVM装载到内存中，JVM会创建一块String Pool（字符串常量池：JDK6.0之前存在于方法区，JDK7.0版本
移到了堆里）。当执行String s ="abc";时，JVM首先在String Pool中查看是否存在字符串对象"abc"（用equals()方法判断），
如果已存在该对象，则不用创建新的字符串对象"abc"，而直接使用String Pool中已存在的对象"abc"，然后将引用s指向该对象；
如果不存在该对象，则先在String Pool中创建一个新的字符串对象"abc"，然后将引用s指向String Pool中创建的新对象。
String s1 = "abc";
String s2 = "abc";
System.out.println(s1 == s2);  //true
2、String s = new String("abc");
创建过程分析：当执行String s = new String("abc");时，JVM首先在String Pool中查看是否存在字符串对象"abc"，如果不存在该
对象，则先在String Pool中创建一个新的字符串对象"abc"，然后执行new String("abc")构造方法，在Heap里又创建一个新的字符串
对象"abc"（new出来的对象都放在Heap里面），并将引用s指向Heap中创建的新对象；如果已存在该对象，则不用创建新的字符串对象
"abc"，而直接使用String Pool中已存在的对象"abc"， 然后执行new String("abc")构造方法，在Heap里又创建一个新的字符串对象
"abc"，并将引用s指向Heap中创建的新对象。所以new String（"abc"）创建字符串对象时，会创建两个对象，String Pool中创建一个，
Heap中创建一个，一个是字符串字面量"abc"所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过
new String(String)创建并初始化的、内容与"abc"相同的实例。
String s1 = new String("abc");
String s2 = new String("abc");
System.out.println(s1 == s2);      //false
System.out.println(s1.equals(s2)); //true

二：OutOfMemoryError异常
1、内存泄漏和内存溢出：
    内存泄漏（Memory Leak）：是指程序在申请内存后，无法释放已申请的内存空间。即分配出去的内存无法回收（不再使用的对象
或者变量仍占内存空间），在Java中内存泄漏就是存在一些被分配的对象（可达的，却是无用的）无法被GC回收。可以理解成内存被
污染了。
    内存溢出（Memory Overflow）：是指程序在申请内存时，没有足够的内存空间供其使用。
2、Java堆溢出问题的处理：
    java.lang.OutOfMemoryError:Java heap space
    ①：先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否
是必要的，即先要分清楚到底是出现了内存泄漏还是内存溢出。
    ②：如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots
相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄漏
代码的位置。
    ③：如果不存在泄漏，就是指内存中的对象确实都必须存活着，就应当检查虚拟机的堆参数（-Xms与-Xmx）与机器物理内存对比看
是否还可以调大；还可以从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
    -Xms：堆的最小值参数（JVM初始分配的堆内存）   -Xmx：堆的最大值参数（JVM最大允许分配的堆内存）
3、虚拟机栈和本地方法栈溢出问题的处理：
    java.lang.StackOverflowError
    栈容量由-Xss参数设定，Xss越大，每个线程的大小就越大，占用的内存越多，能容纳的线程就越少；Xss越小，容易出现栈溢出。
减少局部变量的声明，可以节省栈帧大小，增加调用深度；另外还可以适当调整-Xss参数或者通过-Xms -Xmx两个参数减少Heap大小，
将内存让给Stack（前提是保证Heap空间够用）。
4、方法区和运行时常量池溢出问题的处理：
    java.lang.OutOfMemoryError:PermGen space
    方法区可以理解成永久代，发生这个问题是因为程序中使用了大量的class或jar，使JVM加载类的空间不够。解决方法是可以增加
JVM中的XX:PermSize和XX:MaxPermSize参数的大小，其中XX:PermSize是初始永久保存区大小，XX:MaxPermSize是最大永久保存区大小。


第3章：GC与垃圾收集器
一：对象已死吗？：
1、可达性分析算法（又称为根搜索算法GC Roots Tracing）：
    通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到
GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达），则证明此对象不可用。
    所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。例如：所有Java线程当前活跃的栈帧里指向GC堆
里的对象的引用。
    可作为GC Roots的对象包括如下几种：
        a.虚拟机栈(栈桢中的本地变量表)中引用的对象
        b.方法区中类静态属性引用的对象
        c.方法区中常量引用的对象
        d.本地方法栈中JNI（Native方法）引用的对象
2、引用计数算法（Reference Counting）：
    给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的
对象就是不可能再被使用的。主流Java虚拟机里没有使用引用计数算法，因为很难解决对象之间相互循环引用的问题。

二：垃圾收集算法：
1、标记-清除算法


第4章：虚拟机性能监控与故障处理工具
一：JDK的命令行工具：
1、jps：
虚拟机进程状况工具（JVM Process Status Tool），可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数
所在的类）名称以及这些进程的本地虚拟机唯一ID。
2、jstat：
虚拟机统计信息监视工具（JVM Statistics Monitoring Tool），用于监视虚拟机各种运行状态信息，可以显示本地或者远程虚拟机进程
中的类装载、内存、垃圾收集、JIT编译等运行数据。
3、jinfo：
Java配置信息工具（Configuration Info for Java），作用是实时地查看和调整虚拟机各项参数。
4、jmap：
