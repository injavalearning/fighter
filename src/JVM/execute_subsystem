第三部分：虚拟机执行子系统

第6章：类文件结构
    计算机只认识0和1，所以我们写的程序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行。Java虚拟机不和包括java在
内的任何语言绑定，它只与"Class文件"这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他
辅助信息。使用JRuby和Groovy等语言的编译器也可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言。



第7章：虚拟机类加载机制
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java
类型，这就是虚拟机的类加载机制。
一：类加载的过程
    类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、
准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中
验证、准备、解析3个部分统称为链接（Linking）。
1、加载：
    查找并加载类的二进制数据，在方法区开辟运行时空间给class，还要在堆中开辟内存给对象。
2、验证：
    确保被加载类的正确性，由于class文件未必由java编译而来，所以需要先进行检验。
3、准备：
    为类的静态变量分配内存，并给变量设置初始值（为零值，未赋值）。
4、解析：
    把类中的符号引用转换为直接引用（地址）。符号引用就是一组符号来描述目标，可以是任何字面量；直接引用就是直接指向目标
的指针。
5、初始化：
    为类的静态变量赋予正确的初始值。
    例如 private static int a = 10; 它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步，验证通过
后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a = 0，到初始化这一步时，才把a真正的
值10赋给a，此时a = 10。
    初始化步骤：
    ①、假如这个类还没有被加载和链接，则先进行加载和链接
    ②、假如该类的直接父类还没有被初始化，则先初始化其直接父类
    ③、假如类中有初始化语句（static变量或代码块），则系统依次执行这些初始化语句
    初始化时机：
    ①、创建类的实例，也就是new一个对象
    ②、访问某个类或接口的静态变量，或者对该静态变量赋值
    ③、调用类的静态方法
    ④、反射（Class.forName("com.lyj.load")）
    ⑤、初始化一个类的子类（会首先初始化子类的父类）
    ⑥、JVM启动时标明的启动类，即定义了main()方法的那个类


二、类加载器
1、类加载器：
    JVM提供了3种类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载
器（Application ClassLoader），也可以通过继承java.lang.ClassLoader实现自定义的类加载器。

2、双亲委派模型：
    JVM通过双亲委派模型进行类的加载，当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递
到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，子类加载器才会尝试自己去加载。
    采用双亲委派模型的好处：比如加载位于rt.jar包中的类java.lang.Object，不管是哪个类加载器加载这个类，最终都是委托给顶层
的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。
    注：Java中一个类用其全限定类名（包名和类名）作为其唯一标识，但是在JVM中，一个类用其全限定类名和其类加载器作为其唯一
标识。也就是说，在Java中的同一个类，被同一个虚拟机加载，只要加载它们的类加载器不同，就认为这两个类不相等。这里所指的
“相等”，包括Class对象的equals()方法、isInstance()方法的返回结果，也包括使用instanceOf关键字做对象所属关系判定等情况。
例如：obj1.getClass().equals(obj2.getClass())


三、对象的创建过程 Dog dog = new Dog();
1、虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类
是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程（当虚拟机执行到new指令时，它先在常量池中查找“Dog”，
看能否定位到Dog类的符号引用。如果能，说明这个类已经被加载到方法区了，则继续执行；如果不能，就先执行类的加载）。
2、为新对象分配内存，对象所需的内存大小在类加载完成后就已经确定了，这时候只要在堆中按需分配空间即可。
3、对新对象的成员变量进行默认初始化（0，false，null），虚拟机将分配的内存空间都初始化为零值（不包括对象头）。
4、对新对象头进行初始化，设置对象头信息，比如这个对象是哪个类的实例、对象的哈希值、对象的GC分代年龄等信息。
5、执行构造方法，通过构造方法对对象的成员变量赋值。
6、对象初始化完毕，把对象地址赋给dog变量。


四、HelloWorld的执行过程
1、执行HelloWorld.java文件，生成HelloWorld.class字节码文件。
2、虚拟机执行HelloWorld.class，将这个类加载到内存中。
3、虚拟机通过类找到HelloWorld的main方法（程序的入口方法），访问权限为public，虚拟机传递String[]（字符串数组对象：空数组）
类型参数的地址到main方法的args中去，并在栈区为args开辟内存空间，返回一个void的返回值。
4、定义一个String类型的变量s（在栈区开辟空间），s的值不确定（垃圾值，编译无法通过）。
5、s = "HelloWorld"，在字符串常量池中创建一个新的字符串对象"abc"，然后将引用s指向String Pool中创建的新对象。
6、虚拟机找到标准类库中的System.class类并加载到内存中，System.out为标准字节输出流对象，并调用println()方法将变量s的值
打印到屏幕上。