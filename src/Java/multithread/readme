Java多线程：

一、进程和线程
1、进程：
    是系统进行资源分配和调用的独立单位，每一个进程，都有它自己的内存空间和系统资源。进程指的是程序执行时的一个实例，
程序一旦运行就是一个进程。

2、线程：
    是进程的执行单元、执行路径，线程是CPU调度的基本单位。

3、联系
    同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈等），一个进程至少包括一个线程，一个线程不能
独立的存在，它必须是进程的一部分。
    开启多个线程是为了同时运行多部分代码，多线程能满足程序员编写高效率的程序来达到充分利用CPU的目的。


二、多线程和多进程
1、概念：
    多进程是指操作系统能同时运行多个任务（程序）
    多线程是指在同一程序中有多个顺序流在执行
    JVM启动时就启动了多个线程，至少有两个线程可以分析出来
    1、执行main函数的线程
    2、负责垃圾回收的线程

2、并发和并行：
①、并发：
    通过CPU调度算法，让用户看上去同时执行，实际上是通过CPU在高速切换并不是真正的同时。
②、并行：
    多个CPU实例或者多台机器同时执行一段处理逻辑，这就是真正的同时。

3、Java实现多线程的两种方式：（Thread1和Thread2）
方式一：1、继承Thread类
        2、重写Thread类的run方法，并且将线程要执行的代码存放到run方法中
        3、创建继承Thread类的子类的对象，也就是创建线程
        4、线程对象调用start方法，开启线程，线程会自动执行run方法

方式二：1、实现Runnable接口
           存放线程执行代码的类去实现(implements) Runnable接口
        2、重写所实现接口的run方法，并将线程执行代码存放在run方法中
        3、创建Thread对象，也就是创建线程，并将Runnable接口的子类对象作为参数传给Thread类的构造函数中
        4、Thread线程对象调用start方法，启动线程

两种方式的比较：
实现Runnable接口的方式要好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是
设计模式6大原则的核心。
run()方法与start()方法：run()方法里面存放着Thread线程对象需要执行的代码，调用start()方法，让所创建的线程处于
就绪状态。
为什么不调用run方法而用start方法：start()创建了新线程，当调用start()方法时，系统才会开启一个线程，run()方法没有,
run()实际为主线程，它是被当作普通方法的方式调用。

4、ThreadLocal：
    ThreadLocal的作用是提供线程内的局部变量，是每一个线程单独持有的，其他线程不能对其进行访问。
    它是多线程并发访问共享变量的解决方案，与synchronized等加锁的方式不同，ThreadLocal完全不提供锁，而是以空间换时间，
为每个线程提供变量的独立副本，使用变量的时候用的都是自己从内存中拷贝过来的变量的副本，以保障线程安全。


三、线程安全
1、定义：
    多个线程在执行同一段代码的时候，每次的执行结果和单线程执行的结果都是一样的，不存在执行结果的二义性，就可以说是
线程安全的。

2、线程安全问题产生的原因：（Ticket）
    ①、是否有多线程环境，程序中是否使用了多线程
    ②、是否有共享数据
    ③、是否有多条语句操作共享数据
    当一个线程在执行操作共享数据的代码过程中，其它线程参与了运算，就会导致线程安全问题的产生。

3、多线程安全问题的解决思路：
    就是将操作共享数据的代码封装起来，当有线程在执行这些代码的时候，其他线程就不可以参与运算，必须要当前线程把这些代码
都执行完毕后，其他线程才可以参与运算。

4、解决方案：
    我们使用同步（关键字为synchronized）来解决这种由于多线程同时操作共享数据带来的线程安全问题（火车上的卫生间）
同步可以理解为：我们将多条操作共享数据的语句代码包成一个整体，让某个线程执行时其他线程不能执行（达到多窗口
卖票的同步性，多个窗口可以同时卖（并发），但不会导致重复卖）。
    同步有四种方案：同步代码块、同步方法、volatile实现同步、ReentrantLock实现同步。
注意：同步可以解决问题的根本原因就在于锁对象上，因此要避免线程安全问题，多个线程必须使用同一个锁对象。
    方案一：同步代码块（Ticket1）
        格式：synchronized(对象) {
                   需要被同步的代码;
            }
            这里的锁对象可以是任意对象
    方案二：同步方法（Ticket2）
        格式：把同步（synchronized）加在方法上，这时的锁对象是this
    方案三：volatile实现同步（最轻量级的同步机制），不保证原子性，也就是不能保证卖票（ticketCount--）的同步性；
        但是可以用于
            private volatile boolean flag = true;
            public void run(){
                while(flag)
                    System.out.println("do something");
            }
            public void setFlag(){
                flag = false;
            }
        这种情况，多线程环境下，其中一个线程调用setFlag方法，程序就会停止。
    方案四：Lock锁实现同步
        格式：private Lock lock = new ReentrantLock();
              public void run(){
                    try{
                        lock.lock();
                        需要执行的代码;
                    }finally{
                        lock.unlock();
                    }
              }


四、volatile关键字
1、作用：
    ①、它是变量修饰符，它修饰的变量具有可见性。一旦某个线程修改了被volatile修饰的变量，它会保证修改的值立即被更新
到内存，当有其他线程需要读取时，可以立即获取修改之后的值。
    ②、可以禁止进行指令重排序。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当
于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。
    注意：volatile不保证原子性。

2、volatile和synchronized的区别：
    ①、volatile轻量级，只能修饰变量；synchronized重量级，还可修饰方法和代码块。
    ②、volatile只能保证数据的可见性，不能用来同步，因此多个线程并发访问volatile修饰的变量不会阻塞。
    ③、synchronized可以保证变量的修改可见性和原子性，多个线程争抢synchronized锁对象时，会出现阻塞。

3、一些概念：
    ①、可见性：是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程
马上就能看到。在Java中 volatile、synchronized 和 final 实现可见性。
    ②、原子性：原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型）这个操作是不可分割的，那么我们
说这个操作是原子操作。再比如：a++；这个操作实际是a = a + 1；是可分割的（分割为三步，取出a的值，计算a+1的值，计算结果
写入内存），所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（synchronized）来让它变成一个
原子操作。一个操作是原子操作，那么我们称它具有原子性。在Java中 synchronized 和在 lock、unlock 中操作保证原子性。
    ③、有序性：Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身
包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，
此规则决定了持有同一个对象锁的两个同步块只能串行执行。


五、synchronized与lock的区别：
1、Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。
2、synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过
unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
3、synchronized当线程A获得锁，线程B等待，如果线程A阻塞，线程B会一直等待；ReentrantLock有锁投票、定时锁等候和中断锁
等候，线程可以不用一直等待。
4、Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个
接口的ReentrantLock类、ReentrantReadWriteLock类。
5、从性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的
性能要远远优于synchronized。


六、sleep和wait的区别
1、区别：
    sleep是Thread类的方法，wait是Object类的方法
    sleep方法（休眠）是Thread类的静态方法，调用这个方法会让当前线程暂停执行指定的时间，将CPU让给其他线程，但是线程不会
释放对象锁，因此休眠时间结束后会自动恢复（线程回到就绪状态）。
    wait方法是Object类的方法，是让当前线程自己放弃对象的锁，然后进入到线程等待池，直到其他线程调用notify()或notifyAll()
方法唤醒这个线程。
    注：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与竞争锁
2、notify和notifyAll：
    notify()方法会唤醒一个处于等待状态的线程，如果有多个线程都处于等待状态，会随机选择其中一个线程进行唤醒操作。如果
notify后面还有代码，会继续执行直到当前线程执行完毕才会释放锁；notifyAll是唤醒等待的所有线程。
    注：notify和notifyAll只是唤醒沉睡的线程，而不会立即释放锁


七、Java锁
1、可重入锁：
    同一线程访问外层函数获得锁之后，访问内层函数会自动获取此锁，即在一个线程中可以多次获取同一把锁，比如：一个线程执行
一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁。
    可重入锁的实现原理是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个
未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1。如果同一个线程再次请求这个锁，计数将递增；每次占用线程退出
同步块，计数器值将递减；直到计数器为0，锁被释放。
    Java里ReentrantLock和synchronized都是可重入锁，可重入锁的好处是能防止死锁。详见ReentrantLock_Instance
2、公平锁和非公平锁：
    公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来排队获得锁。
    非公平锁是可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在
等待队列的线程则不会被唤醒。
    

八、Java线程池
1、一个线程的生命周期（五种状态）：
    新建状态、就绪状态、运行状态、阻塞状态、死亡状态

2、线程池概念：
    线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程而不用自己创建，
使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

3、使用线程池的好处：
    ①、重用存在的线程，减少线程对象创建、消亡的开销，性能佳
    ②、可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞
    ③、提供定时执行、定期执行、单线程、并发数控制等功能

4、四种线程池：
    ①、newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照
指定顺序(FIFO, LIFO, 优先级)执行。
    （只有一个线程的“池”，该线程顺序执行每一个提交的任务）
    ②、newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    （包含固定数量的线程，空闲线程会一直被保留）
    ③、newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则
新建线程。
    （必要时创建新线程，空闲线程会被保留60秒）
    ④、newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
    （用于预定执行而构建的固定线程池，替代java.util.Timer）

5、创建线程池：（ThreadPool）
    通过 ExecutorService pool = Executors.newCachedThreadPool(); 创建线程池。

6、线程池四个基本组成部分：
    ①、线程池管理器（ThreadPool）：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务。
    ②、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务。
    ③、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的
收尾工作，任务的执行状态等。
    ④、任务队列（TaskQueue）：用于存放没有处理的任务,提供一种缓冲机制。

7、线程池参数：
    ①、corePoolSize：核心池大小（核心线程数），核心线程会一直存活，即使没有任务需要执行，也是线程池维护线程的最少数量
    ②、maximumPoolSize：线程池最大线程数，表示在线程池中最多能创建多少个线程
    ③、keepAliveTime：表示线程没有任务执行时最多保持多长时间会终止
    ④、workQueue：一个阻塞队列，用来存储等待执行的任务，类型为BlockingQueue
    ⑤、threadFactory：线程工厂，主要用来创建线程，类型为ThreadFactory
    ⑥、handler：线程池对拒绝任务的处理策略，类型为RejectedExecutionHandler

8、合理配置线程池大小：
一般需要根据任务的类型来配置线程池大小：
如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为Ncpu+1
如果是IO密集型任务，参考值可以设置为2*Ncpu
结论：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。